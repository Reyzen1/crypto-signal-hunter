# analysis/technical_analyzer.py
"""
This module provides the core analysis engine for the cryptocurrency data.

It defines the CryptoAnalyzer class, which is responsible for creating a
DataFrame from raw market data, calculating various technical indicators,
and generating trading signals based on that analysis.
"""

import pandas as pd
import pandas_ta as ta

class CryptoAnalyzer:
    """
    Performs all technical analysis calculations and signal generation.

    This class encapsulates the entire analysis process, from data
    preprocessing to indicator calculation and signal interpretation.
    """

    def __init__(self, market_data):
        """
        Initializes the analyzer with raw market data from the API.

        Args:
            market_data (dict): The raw JSON-like data from the CoinGecko API.

        Raises:
            ValueError: If the market_data is invalid, empty, or missing
                        essential keys like 'prices' or 'total_volumes'.
        """
        if not market_data or 'prices' not in market_data or 'total_volumes' not in market_data:
            raise ValueError("Invalid or incomplete market data provided.")
        self.market_data = market_data
        self.df = self._create_dataframe()

    def _create_dataframe(self):
        """
        Converts the raw market data into a clean, merged pandas DataFrame.

        The method processes prices and volumes separately, converts timestamps
        to datetime objects, and merges them into a single DataFrame indexed by date.

        Returns:
            pd.DataFrame: A DataFrame with 'price' and 'volume' columns, indexed by 'date'.
        """
        df_price = pd.DataFrame(self.market_data['prices'], columns=['timestamp', 'price'])
        df_price['date'] = pd.to_datetime(df_price['timestamp'], unit='ms')
        df_price = df_price.set_index('date').drop('timestamp', axis=1)

        df_volume = pd.DataFrame(self.market_data['total_volumes'], columns=['timestamp', 'volume'])
        df_volume['date'] = pd.to_datetime(df_volume['timestamp'], unit='ms')
        df_volume = df_volume.set_index('date').drop('timestamp', axis=1)

        return pd.merge(df_price, df_volume, on='date', how='inner')

    def add_all_indicators(self):
        """
        Calculates and appends all technical indicators to the DataFrame.

        This method uses standard pandas rolling means and the pandas_ta library
        to compute SMAs, MACD, and RSI.

        Returns:
            pd.DataFrame: The DataFrame with added indicator columns.
        """
        if self.df.empty:
            return self.df

        self.df['SMA_10'] = self.df['price'].rolling(window=10).mean()
        self.df['SMA_30'] = self.df['price'].rolling(window=30).mean()

        self.df.ta.macd(close=self.df['price'], append=True)
        self.df.ta.rsi(close=self.df['price'], append=True)
        
        # Drop rows with NaN values that are generated by the indicators
        self.df.dropna(inplace=True)
        
        return self.df

    def generate_signals(self):
        """
        Interprets the indicator values to generate actionable trading signals.

        This method checks the latest data point for conditions like RSI overbought/oversold
        and MACD crossovers to produce a list of human-readable signals.

        Returns:
            list: A list of tuples, where each tuple contains the signal type (str)
                  and the signal message (str).
        """
        signals = []
        if len(self.df) < 2:
            return signals

        latest = self.df.iloc[-1]
        previous = self.df.iloc[-2]

        # RSI Signal Analysis
        rsi_value = latest['RSI_14']
        if rsi_value > 70:
            signals.append(('warning', f"RSI is at {rsi_value:.2f}, indicating the asset might be **Overbought**."))
        elif rsi_value < 30:
            signals.append(('success', f"RSI is at {rsi_value:.2f}, indicating the asset might be **Oversold**."))
        else:
            signals.append(('info', f"RSI is at {rsi_value:.2f}, which is in the **Neutral Zone**."))

        # MACD Analysis
        macd_line, signal_line = 'MACD_12_26_9', 'MACDs_12_26_9'
        is_bullish_crossover = previous[macd_line] < previous[signal_line] and latest[macd_line] > latest[signal_line]
        is_bearish_crossover = previous[macd_line] > previous[signal_line] and latest[macd_line] < latest[signal_line]

        if is_bullish_crossover:
            signals.append(('success', "**ðŸ”¥ Bullish MACD Crossover** detected! This is a strong BUY signal."))
        elif is_bearish_crossover:
            signals.append(('error', "**ðŸš¨ Bearish MACD Crossover** detected! This is a strong SELL signal."))
        else:
            if latest[macd_line] > latest[signal_line]:
                signals.append(('info', f"**MACD Bullish Trend:** The MACD line is **above** the Signal line."))
            else:
                signals.append(('warning', f"**MACD Bearish Trend:** The MACD line is **below** the Signal line."))
        
        return signals